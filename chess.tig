let
    /**********************
          Color Constants  
    ***********************/ 
    var WHITE := 0
    var BLACK := 1

    /***********************
          Piece Constants  
    ************************/ 

    var PAWN := 0
    var ROOK := 1
    var KNIGHT := 2
    var BISHOP := 3
    var QUEEN := 4
    var KING := 5


    /***********************
          Types   
    ************************/
    type bool = int 
    type coordinate = {file: int, rank: int}
    type moveCoords = {fromC : coordinate, toC : coordinate}
    type piece = {color: int, piece: int}

    type row = array of piece    
    type board = array of row

    type game = {board: board,
                 turn: int,
		 whiteKingLoc: coordinate,
                 blackKingLoc: coordinate,
		 whiteCanShortCastle: bool,
		 blackCanShortCastle: bool,
		 whiteCanLongCastle: bool,
		 blackCanLongCastle: bool,
		 enPassantable: coordinate,
		 fiftyMoveCounter: int}

    /****************************
        Piece Constants
    ****************************/

     var EMPTY := piece{color=-1, piece=-1}
     
     var WHITE_PAWN := piece{color=WHITE, piece=PAWN}
     var WHITE_ROOK := piece{color=WHITE, piece=ROOK}
     var WHITE_KNIGHT := piece{color=WHITE, piece=KNIGHT}
     var WHITE_BISHOP := piece{color=WHITE, piece=BISHOP}
     var WHITE_QUEEN := piece{color=WHITE, piece=QUEEN}
     var WHITE_KING := piece{color=WHITE, piece=KING}
     
     var BLACK_PAWN := piece{color=BLACK, piece=PAWN}
     var BLACK_ROOK := piece{color=BLACK, piece=ROOK}
     var BLACK_KNIGHT := piece{color=BLACK, piece=KNIGHT}
     var BLACK_BISHOP := piece{color=BLACK, piece=BISHOP}
     var BLACK_QUEEN := piece{color=BLACK, piece=QUEEN}
     var BLACK_KING := piece{color=BLACK, piece=KING}

     
    /****************************
           Coordinate Constants
     ***************************/
     var NO_COORD := coordinate{file=-1, rank=-1}
     var A1 := coordinate{file=0, rank=0}
     var A2 := coordinate{file=0, rank=1}
     var A3 := coordinate{file=0, rank=2}
     var A4 := coordinate{file=0, rank=3}
     var A5 := coordinate{file=0, rank=4}
     var A6 := coordinate{file=0, rank=5}
     var A7 := coordinate{file=0, rank=6}
     var A8 := coordinate{file=0, rank=7}

     var B1 := coordinate{file=1, rank=0}
     var B2 := coordinate{file=1, rank=1}
     var B3 := coordinate{file=1, rank=2}
     var B4 := coordinate{file=1, rank=3}
     var B5 := coordinate{file=1, rank=4}
     var B6 := coordinate{file=1, rank=5}
     var B7 := coordinate{file=1, rank=6}
     var B8 := coordinate{file=1, rank=7}
     
     var C1 := coordinate{file=2, rank=0}
     var C2 := coordinate{file=2, rank=1}
     var C3 := coordinate{file=2, rank=2}
     var C4 := coordinate{file=2, rank=3}
     var C5 := coordinate{file=2, rank=4}
     var C6 := coordinate{file=2, rank=5}
     var C7 := coordinate{file=2, rank=6}
     var C8 := coordinate{file=2, rank=7}
         
     var D1 := coordinate{file=3, rank=0}
     var D2 := coordinate{file=3, rank=1}
     var D3 := coordinate{file=3, rank=2}
     var D4 := coordinate{file=3, rank=3}
     var D5 := coordinate{file=3, rank=4}
     var D6 := coordinate{file=3, rank=5}
     var D7 := coordinate{file=3, rank=6}
     var D8 := coordinate{file=3, rank=7}
     
     var E1 := coordinate{file=4, rank=0}
     var E2 := coordinate{file=4, rank=1}
     var E3 := coordinate{file=4, rank=2}
     var E4 := coordinate{file=4, rank=3}
     var E5 := coordinate{file=4, rank=4}
     var E6 := coordinate{file=4, rank=5}
     var E7 := coordinate{file=4, rank=6}
     var E8 := coordinate{file=4, rank=7}
     
     var F1 := coordinate{file=5, rank=0}
     var F2 := coordinate{file=5, rank=1}
     var F3 := coordinate{file=5, rank=2}
     var F4 := coordinate{file=5, rank=3}
     var F5 := coordinate{file=5, rank=4}
     var F6 := coordinate{file=5, rank=5}
     var F7 := coordinate{file=5, rank=6}
     var F8 := coordinate{file=5, rank=7}
     
     var G1 := coordinate{file=6, rank=0}
     var G2 := coordinate{file=6, rank=1}
     var G3 := coordinate{file=6, rank=2}
     var G4 := coordinate{file=6, rank=3}
     var G5 := coordinate{file=6, rank=4}
     var G6 := coordinate{file=6, rank=5}
     var G7 := coordinate{file=6, rank=6}
     var G8 := coordinate{file=6, rank=7}
     
     var H1 := coordinate{file=7, rank=0}
     var H2 := coordinate{file=7, rank=1}
     var H3 := coordinate{file=7, rank=2}
     var H4 := coordinate{file=7, rank=3}
     var H5 := coordinate{file=7, rank=4}
     var H6 := coordinate{file=7, rank=5}
     var H7 := coordinate{file=7, rank=6}
     var H8 := coordinate{file=7, rank=7}

     /*****************************************/
     
     /* Absolute value function */
     function abs(x : int) : int =
         if x < 0 then x * -1 else x
	 
     /* Checks if file and rank are equal to a coordiante */ 
     function isSquare (file : int, rank : int, square : coordinate) : bool =
         if (file = square.file & rank = square.rank)
	     then 1
	     else 0

     /* Initially,
        - the pieces are on their starting squares,
        - it is white's turn. The kings are on e1 and e8,
	- no pawn moved 2 squares last turn (thus nothing can be captured via
            en passant)
	- the fifty move counter starts at 0
     */
     function initGame() : game =
     let 
         /* Initializes the board at the beginning of the game
	    - White pawns on the 2nd rank, black pawns on the 7th rank
	    - Rank 1 contains white: rook, knight, bishop, queen, king, bishop, knight, rook
	    - Rank 8 contains black: rook, knight, bishop, queen, king, bishop, knight, rook
	    - White and black can still castle short or long 
	 */ 
	 function initBoard () : board =
		 /* Need to make the rows here so they dont point to same object */
	     let var r0 := row [8] of EMPTY
		 var r1 := row [8] of WHITE_PAWN
		 var r2 := row [8] of EMPTY
		 var r3 := row [8] of EMPTY
		 var r4 := row [8] of EMPTY
		 var r5 := row [8] of EMPTY
		 var r6 := row [8] of BLACK_PAWN
		 var r7 := row [8] of EMPTY

		 var b := board [8] of r0
	     in
		 /* Make each row a unique array */ 
		 b[1] := r1;
		 b[2] := r2;
		 b[3] := r3;
		 b[4] := r4;
		 b[5] := r5;
		 b[6] := r6;
		 b[7] := r7;

		 /* Insert major pieces at correct location
		    Note: Pawns already were initialized.
		  */ 
		 for rank := 0 to 7 do
		     for file := 0 to 7 do	
			 if (rank = 0) then 
			       (if     (file = 0 | file=7) then b[rank][file] := WHITE_ROOK
			       else if (file = 1 | file=6) then b[rank][file] := WHITE_KNIGHT
			       else if (file = 2 | file=5) then b[rank][file] := WHITE_BISHOP
			       else if (file = 3)          then b[rank][file] := WHITE_QUEEN
			       else if (file = 4)          then b[rank][file] := WHITE_KING)
			 else if (rank = 7) then
			       (if     (file = 0 | file=7) then b[rank][file] := BLACK_ROOK
			       else if (file = 1 | file=6) then b[rank][file] := BLACK_KNIGHT
			       else if (file = 2 | file=5) then b[rank][file] := BLACK_BISHOP
			       else if (file = 3)          then b[rank][file] := BLACK_QUEEN
			       else if (file = 4)          then b[rank][file] := BLACK_KING);

		 b 	/* Returns the updated board */ 
	     end
           in
	       game{board=initBoard(),
	            turn=WHITE,
		    whiteKingLoc=E1,
		    blackKingLoc=E8,
		    whiteCanShortCastle=1,
		    blackCanShortCastle=1,
		    whiteCanLongCastle=1,
		    blackCanLongCastle=1,
		    enPassantable=NO_COORD,
		    fiftyMoveCounter=0}
	   end 


       function printMove(p : piece, fromC : coordinate, toC : coordinate) =
           let function printCoordinate(c : coordinate) =
               let function fileToStr(f : int) : string = chr(f + 97)
	           function rankToStr(r : int) : string = chr(r + 49)
	           var str := concat(fileToStr(c.file), rankToStr(c.rank))
	       in
	           print(str)
               end

               var horizontal := abs(fromC.file - toC.file)
	       var castledLong := p.piece = KING & horizontal = 2 &  toC.file = 2
	       var castledShort := p.piece = KING & horizontal = 2 & toC.file = 6
	     
	   in
	       if      castledShort then print("O-O\n")
	       else if castledLong  then print("O-O-O\n")
	       else 
 	           (print("Moved ");
		    printCoordinate(fromC);
		    print(" to ");
		    printCoordinate(toC);
		    print("\n"))
	   end
	       
	
       function printBoard (g : game) =
           let var b := g.board  
	       var rank := 7
	   
	       /* Emulators for MIPS R2000 don't seem to support unicode sadly */ 
               function printPiece (p : piece) =
                   if      p = WHITE_PAWN   then print("WP")
	           else if p = WHITE_ROOK   then print("WR")
	           else if p = WHITE_KNIGHT then print("WN")
	           else if p = WHITE_BISHOP then print("WB")
	           else if p = WHITE_QUEEN  then print("WQ")
	           else if p = WHITE_KING   then print("WK")
	           else if p = BLACK_PAWN   then print("BP")
	           else if p = BLACK_ROOK   then print("BR")
	           else if p = BLACK_KNIGHT then print("BN")
	           else if p = BLACK_BISHOP then print("BB")
	           else if p = BLACK_QUEEN  then print("BQ")
	           else if p = BLACK_KING   then print("BK")
	           else print ("  ")

	   in 
             while rank >= 0 do	     
	       (print("     -----------------------------------------\n");
	        print("   "); print(chr(rank + 49)); print(" | ");
	        for file := 0 to 7 do
	           let var p := b[rank][file]
		   in
		       printPiece(p);
		       print(" | ")
		   end;	
	       print("\n");
	       rank := rank - 1);
	     print("     -----------------------------------------\n");
	     print("       a    b    c    d    e    f    g    h\n\n")
	   end


       /***********************************
            Piece predicate functions
	***********************************/
       function isKnight(p : piece) : bool =
           p.piece = KNIGHT
       function isRook(p : piece) : bool =
           p.piece = ROOK
       function isBishop(p : piece) : bool =
           p.piece = BISHOP
       function isPawn(p : piece) : bool =
           p.piece = PAWN
       function isQueen(p : piece) : bool =
           p.piece = QUEEN
       function isKing(p : piece) : bool =
           p.piece = KING

       function isWhite(p : piece) : bool =
           p.color = WHITE
       function isBlack(p : piece) : bool =
           p.color = BLACK

       /****************************************
             Helpers for Legal Move Checks
	****************************************/
	
       /* Check if two coordinates are on the same diagonal. */
       function isDiagonal(fromC : coordinate, toC : coordinate) : bool =
           let var dx := abs(fromC.file - toC.file) 
	       var dy := abs(fromC.rank - toC.rank)
	   in
	       (dx = dy) & (dx <> 0)
	   end	   
	   

       function canSeeSquare(b : board, fromC : coordinate, toC : coordinate) : bool =
           let function noPiecesBetweenHorizontally (b : board, fromC : coordinate, toC : coordinate) : bool =
               	    let var low := if fromC.file <= toC.file then fromC.file else toC.file
	       		var high := if fromC.file <= toC.file then toC.file else fromC.file	       
	       		var rank := fromC.rank /* Invariant: fromC.rank = toC.rank */ 
	       		var res := 1
	    	     in
               	        for file := (low + 1) to (high - 1) do
	           	    if b[rank][file] <> EMPTY
		       	       then (res := 0; break);
	       		res			
               	     end
		     
	       function noPiecesBetweenVertically (b : board, fromC : coordinate, toC : coordinate) : bool =
                     let var low := if fromC.rank <= toC.rank then fromC.rank else toC.rank
	                 var high := if fromC.rank <= toC.rank then toC.rank else fromC.rank	       
	                 var file := fromC.file /* Invariant: fromC.file = toC.file */ 
	                 var res := 1
	             in
                         for rank := (low + 1) to (high - 1) do
	                     if b[rank][file] <> EMPTY
		                 then (res := 0; break);
	                 res
	             end

       
               function noPiecesBetweenDiagonally (b : board, fromC : coordinate, toC : coordinate) : bool =
               	     let var toRank := toC.rank
			 var toFile := toC.file

                         var vertStep := if fromC.rank < toRank 
			                 then 1
					 else -1
			 var horizStep := if fromC.file < toFile 
			                  then 1
					  else -1

                         var fromRank := fromC.rank + vertStep
			 var fromFile := fromC.file + horizStep

	                 var res := 1
	             in
                         while fromRank <> toRank do
	                     (if b[fromRank][fromFile] <> EMPTY
		                 then (res :=0; break);
		              fromRank := fromRank + vertStep;
		              fromFile := fromFile + horizStep);
		    
	                 res 
	             end
	   in 
               if fromC = toC then 1
	       else
	           let var horizontal := fromC.rank = toC.rank
	               var vertical   := fromC.file = toC.file
		       var diagonal   := isDiagonal(fromC, toC)
	           in
	               if       horizontal then noPiecesBetweenHorizontally(b, fromC, toC)
		       else if  vertical   then noPiecesBetweenVertically(b, fromC, toC)
		       else if  diagonal   then noPiecesBetweenDiagonally(b, fromC, toC)
		       else 0
	           end
           end 


       /****************************************
                   Legal Move Checks
	****************************************/
       function legalPawnMove(g : game, p : piece, fromC : coordinate, toC : coordinate) : bool =
           let var b := g.board 
	       var vertical := toC.rank - fromC.rank
	       var horizontal := toC.file - fromC.file

	       var goingUp := vertical > 0
	       var goingDown := vertical < 0	       
	       var wrongDirection := (goingDown & isWhite(p)) | (goingUp & isBlack(p))
	       var capturing := abs(vertical) = 1 & abs(horizontal) = 1	       
	       
	       function nextToEnPassantable () : bool =
	           let var leftLegal := 0
		       var rightLegal := 0
		       var leftFile := fromC.file - 1
		       var rightFile := fromC.file + 1
		       var currPiece := getPiece(b, fromC)
		       var currColor := currPiece.color
		       var leftPiece := b[fromC.rank][leftFile]
                       var rightPiece := b[fromC.rank][rightFile]
							       
		   in 
	               if leftPiece <> EMPTY & leftFile >= 0
		           then leftLegal :=
			       (g.enPassantable.file = leftFile 
			        & leftPiece.color <> currColor);
				
		       if rightPiece <> EMPTY & rightFile <= 7
		           then rightLegal :=
			       (g.enPassantable.file = rightFile 
			        & rightPiece.color <> currColor);

                       /* True if an en passantable pawn is on the left or right */ 
                       leftLegal | rightLegal
		   end
		   
	       var canEnPassant := nextToEnPassantable()
		
		       

	   in
	       /* FAIL: White pawn going down or black pawn going up */ 
	       if wrongDirection
	           then 0

               /* Double jump case only legal on first move */ 
	       else if (abs(vertical) = 2 & horizontal = 0)
	           then (isWhite(p) & fromC.rank = 1) | (isBlack(p) & fromC.rank = 6)

               /* Capture case. Only legal if there is a piece to capture
	        */
	       else if capturing & not(canEnPassant)
	           then (getPiece(b, toC) <> EMPTY)

               /* En passant case. Only legal if the square adjacent has an
	          en passantable pawn */ 
               else if (capturing & canEnPassant)
	           then 1 

               /* One move forward case. Only legal if there is not a piece
	          on that square
		*/ 
               else if (abs(vertical) = 1 & abs(horizontal) = 0)
	           then (getPiece(b, toC) = EMPTY)

               else 0
	   end 
	       
	            
       function legalKnightMove(fromC : coordinate, toC : coordinate) : bool =
           let var vertical   := abs(fromC.rank - toC.rank)
	       var horizontal := abs(fromC.file - toC.file)
	   in
	       (horizontal = 2 & vertical = 1) | (horizontal = 1 & vertical = 2)
	   end
	   
       function legalRookMove (fromC : coordinate, toC : coordinate) : bool =
           fromC.rank = toC.rank | fromC.file = toC.file

       function legalBishopMove (fromC : coordinate, toC : coordinate) : bool =
           isDiagonal(fromC, toC)

       function legalQueenMove (fromC : coordinate, toC : coordinate) : bool =
           legalRookMove(fromC, toC) | legalBishopMove(fromC, toC)	       
       
       function legalKingMove (g : game, p : piece, fromC : coordinate, toC : coordinate) : bool =
           let
	       /* Check that the king isn't passing through danger on the E, F or G files. */
	       function legalShortCastle(color : int) : bool =
	          not(movingExposesMyKing(g, fromC, coordinate{file=5, rank=toC.rank}, color))
		  & 
		  not(movingExposesMyKing(g, fromC, coordinate{file=6, rank=toC.rank}, color))

               /* Check that the king isn't passing through danger on the E, D, or C files. */
               function legalLongCastle(color : int) : bool =
	          not(movingExposesMyKing(g, fromC, coordinate{file=3, rank=toC.rank}, color))
		  &
		  not(movingExposesMyKing(g, fromC, coordinate{file=2, rank=toC.rank}, color))

               var color := p.color	       
	       var vertical := fromC.rank - toC.rank
	       var horizontal := fromC.file - toC.file
	       var castledShort := abs(horizontal) = 2 & vertical = 0 & toC.file = 6
	       var castledLong := abs(horizontal) = 2 & vertical = 0 & toC.file = 2
	       var regularMove := abs(vertical) <= 1 & abs(horizontal) <= 1 
               	   	           & not(vertical = 0 & horizontal = 0)
	       var inCheck := if color = WHITE then whiteInCheck(g)
	                                       else blackInCheck(g)
           in    
	       
	       if      castledShort & not(inCheck)  then legalShortCastle(color)
	       else if castledLong & not(inCheck)   then legalLongCastle(color)
	       else if regularMove
	           then not(movingExposesMyKing(g, fromC, toC, color))
	       else 0
           end
           

       function attackingWhiteKing(g : game, c : coordinate) : bool =
           let var b := g.board
	       var p := getPiece(b, c)
	       var kingLoc := g.whiteKingLoc
	       var canSee := canSeeSquare(b, c, kingLoc) | isKnight(p)
	   in
	       /* This will return false for empty squares and squares with
	          white pieces */ 
	       if p.color = BLACK & canSee then 
	           if isRook(p) then
		      (c.file = kingLoc.file | c.rank = kingLoc.rank)
		   else if isBishop(p) then
		      isDiagonal(c, kingLoc)
		   else if isQueen(p) then
		      (c.file = kingLoc.file | c.rank = kingLoc.rank) | isDiagonal(c, kingLoc)
		   else if isKnight(p) then
		      legalKnightMove(c, kingLoc)
		   else if isPawn(p) then
		      legalPawnMove(g, p, c, kingLoc)
		   else
		      (abs(c.file - kingLoc.file) <= 1 & 
                       abs(c.rank - kingLoc.rank) <= 1)
	       else 0
	   end 

 
       function attackingBlackKing(g : game, c : coordinate) : bool =
           let var b := g.board
	       var p := getPiece(b, c)
	       var kingLoc := g.blackKingLoc
	       var canSee := canSeeSquare(b, c, kingLoc) | isKnight(p)
	   in
	       /* This will return false for empty squares and squares with
	          black pieces */ 
	       if p.color = WHITE & canSee then
	           if isRook(p) then
		      (c.file = kingLoc.file | c.rank = kingLoc.rank)
		   else if isBishop(p) then
		      isDiagonal(c, kingLoc)
		   else if isQueen(p) then
		      (c.file = kingLoc.file | c.rank = kingLoc.rank) | isDiagonal(c, kingLoc)
		   else if isKnight(p) then
		      legalKnightMove(c, kingLoc)
		   else if isPawn(p) then
		      legalPawnMove(g, p, c, kingLoc)
		   else
		      (abs(c.file - kingLoc.file) <= 1 & 
                       abs(c.rank - kingLoc.rank) <= 1)
	       else 0
	   end
	   
       	   
        /* This is pretty inefficent, but gets the job done */ 
       function hasAMove(g : game) : bool =
           let var res := 0
	       var fromCoord := coordinate{file=0, rank=0}
	       var toCoord := coordinate{file=0, rank=0}
	   in
               (for fromR := 0 to 7 do
	          ((for fromF := 0 to 7 do
		     ((for toR := 0 to 7 do
		        ((for toF := 0 to 7 do
			    let 
		            in
			        fromCoord.file := fromF;
				fromCoord.rank := fromR;
				toCoord.file := toF;
				toCoord.rank := toR;
			        if legalMove(g, fromCoord, toCoord)
			            then (res := 1; break)
			    end);
			 if res = 1 then break));
		      if res = 1 then break));
		   if res = 1 then break));
		   
		res
            end


         /* Checks if the game is a draw by material count */ 
         function sufficientMaterial(g : game) : bool =
	     let var wBishops := 0
	         var wKnights := 0
		 var bBishops := 0
		 var bKnights := 0 
		 var res := 0
             in
	         for rank := 0 to 7 do
		    ((for file := 0 to 7 do
		        let var p := g.board[rank][file]
			in 
		            if p <> EMPTY then
			        /* There is sufficient material if there is a rook, queen, or pawn on the board */ 
			        if (p.piece = ROOK | p.piece = QUEEN | p.piece = PAWN) then (res := 1; break)
		                else if p = WHITE_BISHOP then wBishops := wBishops + 1 
			        else if p = WHITE_KNIGHT then wKnights := wKnights + 1
			        else if p = BLACK_BISHOP then bBishops := bBishops + 1 
			        else if p = BLACK_KNIGHT then bKnights := bKnights + 1
		         end);
		      if res = 1 then break);

                 /* Sufficient material (queen, rook, or pawn found) */
                 if res then res

                 /* Sufficient material (2 bishops)
		    TODO: Technically only not a draw if the bishops are not
		          on the same color, but this is unlikely! 
		 */ 
		 else if wBishops >= 2 | bBishops >= 2
		      then 1

                 /* Sufficient material (bishop + knight) */ 
		 else if (wBishops >= 1 & wKnights >= 1) | (bBishops >= 1 & bKnights >= 1)
		      then 1

                 /* Any other case is insufficient material */ 
                 else 0 
              end 
             
				
       
       /* Iterates through all squares, and checks if they are attacking the
          white king
          - This is slightly inefficient. A better way would be to get all
	    the squares that can see the whiteKingLoc, and then only iterate
	    through those coordinates. 
        */
       function whiteInCheck(g : game) : bool =
           let var res : bool := 0
	       var coord := coordinate{file=0, rank=0}
	   in 
               for rank := 0 to 7 do
	           for file := 0 to 7 do
		       (coord.file := file;
		        coord.rank := rank;
	                if attackingWhiteKing(g, coord)
		           then res := 1);
               res
           end

       function blackInCheck(g : game) : bool =
           let var res : bool := 0
	       var coord := coordinate{file=0, rank=0}
	   in 
               for rank := 0 to 7 do
	           for file := 0 to 7 do
		       (coord.file := file;
		        coord.rank := rank;
	                if attackingBlackKing(g, coord)
		           then res := 1);
               res
           end 	       
			   
	           
       function movingExposesMyKing(g : game, fromC : coordinate, toC : coordinate, color : int) : bool =
           let var exposes := 0
	       var p := getPiece(g.board, fromC)
	       var destP := getPiece(g.board, toC)
	       var oldWhiteKingLoc := g.whiteKingLoc
	       var oldBlackKingLoc := g.blackKingLoc 
             in

                 if p = WHITE_KING then g.whiteKingLoc := toC;
		 if p = BLACK_KING then g.blackKingLoc := toC;
		 
	       /* The below logic tries moving the piece at fromC to toC, and then
		  checks if the king is in check as a result */

	       /* The only "weird" moves to account for here are castling and en
		  passant. Castling logic is handled specially in the
		  legalKingMove function.

		  It is NEVER possible for an en passant to expose a line to
		  the king where the captured pawn was, since this would mean
		  the king could have been captured on the previous term. So,
		  we don't need to do the special en passant move logic here
		  when trying the move!

		  In other words, it's okay to not temporarily delete the captured
		  pawn in an en passant. 
	       */
	       if color = WHITE then 
			(setPiece(g.board, fromC, EMPTY); /* Temp remove the piece */
			 setPiece(g.board, toC, p);
			 exposes := whiteInCheck(g);
			 setPiece(g.board, fromC, p); /* Insert the moved piece back */
			 setPiece(g.board, toC, destP)) /* Insert the captured piece back */

	       else if color = BLACK then 
		       (setPiece(g.board, fromC, EMPTY);
			setPiece(g.board, toC, p);
			exposes := blackInCheck(g);
			setPiece(g.board, fromC, p);
			setPiece(g.board, toC, destP));

               g.whiteKingLoc := oldWhiteKingLoc;
	       g.blackKingLoc := oldBlackKingLoc;
	       
	       exposes
	   end
				    

	   
       function legalMove(g : game, fromC : coordinate, toC : coordinate) : bool =
           let var b := g.board
	   in
	       /* Fail: Index out of bounds */ 
	       if fromC.file < 0 | toC.file < 0 | fromC.rank < 0 | toC.rank < 0
	          | fromC.file > 7 | toC.file > 7 | fromC.file > 7 | toC.rank > 7
		  then 0
	      else
	       let 
	          var pFrom := getPiece(b, fromC)
	          var pTo   := getPiece(b, toC)
	       in
		  /* FAIL: From square is empty */ 
		  if      (pFrom = EMPTY) then 0

		  /* FAIL: Trying to move the opponent's piece */
		  else if (pFrom.color <> g.turn) then 0

		  /* FAIL: Trying to capture your own piece */ 
		  else if (pFrom.color = pTo.color) then 0

		  /* FAIL: From piece is not a knight, and can't see dest. square */
		  else if (not(isKnight(pFrom)) & canSeeSquare(b, fromC, toC) = 0)
			then 0

		  /* FAIL: Moving gets YOUR king killed */
		  else if movingExposesMyKing(g, fromC, toC, pFrom.color) then 0

		  else if isRook(pFrom)    then legalRookMove(fromC, toC)
		  else if isKnight(pFrom)  then legalKnightMove(fromC, toC)
		  else if isBishop(pFrom)  then legalBishopMove(fromC, toC)
		  else if isQueen(pFrom)   then legalQueenMove(fromC, toC)
		  else if isPawn(pFrom)    then legalPawnMove(g, pFrom, fromC, toC)
		  else if isKing(pFrom)    then legalKingMove(g, pFrom, fromC, toC)

		  else 0
	      end
	  end 

       /****************************************
                       Moving Pieces
        ****************************************/
       /* Index into board to get a piece at a coord */ 
       function getPiece(b : board, c : coordinate) : piece =
           b[c.rank][c.file]


       /* Index into board to set a piece at a coord */
       function setPiece(b : board, c : coordinate, p : piece) =
           b[c.rank][c.file] := p
	   
       function move(g : game, fromC : coordinate, toC : coordinate) =
           let var b := g.board
               var p := getPiece(b, fromC)
	       var captureP := getPiece(b, toC)
	       
	       /* If a pawn moved 2 squares, set that coordinate to be
	          en passantable for next turn */ 
	       function updateEnPassantable() =
		   let function pawnDoubleJump() : bool =
			   let var vertical := abs(fromC.rank - toC.rank)
			   in
			       if isPawn(p) & vertical = 2
				   then 1
				   else 0
			   end
	           in
		       if pawnDoubleJump()
		           then g.enPassantable := toC
		           else g.enPassantable := NO_COORD 
		   end

               /* Return true if a move is an en passant */ 
               function isEnPassant() : bool =
	           let var vertical := abs(fromC.rank - toC.rank)
		       var horizontal := abs(fromC.file - toC.file)
		   in
		       /* It's an en passant if it's a pawn capture where
		          the destination square is empty */ 
		       if (isPawn(p) & vertical = 1 & horizontal = 1 &
		          getPiece(b, toC) = EMPTY)
			  then 1
			  else 0
	           end
			  
	       /* Special handling for the en passant move, since
	          it's the only move where a piece gets captured on a square
		  different than the destination square */ 
	       function moveEnPassant() =
	           let var captureC := if p.color = WHITE
		                         then coordinate{file=toC.file,
          				                 rank=toC.rank - 1}
					 else coordinate{file=toC.file,
					                 rank=toC.rank + 1}
                   in
		       setPiece(b, fromC, EMPTY);
		       setPiece(b, toC, p);
		       setPiece(b, captureC, EMPTY)
                   end

                function isCastling() : bool =
		    let var horizontal := fromC.file - toC.file
		        var isKing := p.piece = KING
	            in
		        isKing & abs(horizontal) = 2
		    end 			
			
                function moveCastling() =
		    let var horizontal := toC.file - fromC.file
		    in
		        /* White king long castling case */ 
			if p = WHITE_KING & horizontal = -2
			   then (setPiece(b, C1, WHITE_KING);
			         setPiece(b, D1, WHITE_ROOK);
				 setPiece(b, A1, EMPTY);
				 setPiece(b, E1, EMPTY))

                        /* White king short castling */ 
			else if p = WHITE_KING & horizontal = 2
			   then (setPiece(b, G1, WHITE_KING);
			         setPiece(b, F1, WHITE_ROOK);
				 setPiece(b, H1, EMPTY);
				 setPiece(b, E1, EMPTY))

                        /* Black king long castling case */ 
			else if p = BLACK_KING & horizontal = -2
			   then (setPiece(b, C8, BLACK_KING);
			         setPiece(b, D8, BLACK_ROOK);
				 setPiece(b, A8, EMPTY);
				 setPiece(b, E8, EMPTY))

                        /* Black king short castling */ 
			else if p = BLACK_KING & horizontal = 2
			   then (setPiece(b, G8, BLACK_KING);
			         setPiece(b, F8, BLACK_ROOK);
				 setPiece(b, H8, EMPTY);
				 setPiece(b, E8, EMPTY))
                     end 			  
		    
                /* The king can never castle short or long IF:
		     - The king moved (either normally or by castling)
		   The king can never castle short IF:
		     - The h file rook moved 
		   The king can never castle long IF:
		     - The a file rook moved 
		 */
                function updateCanCastle() =
		    let var color := p.color
		        var kingMoved := p.piece = KING
			var rookMoved := p.piece = ROOK
			var canStillCastle := g.whiteCanShortCastle | g.whiteCanLongCastle
			                    | g.blackCanShortCastle | g.blackCanLongCastle 
	            in
		        /* Only need to check this if any of the canStillCastle
			   bools are true */ 
		        if canStillCastle then 
			    (if color = WHITE
			       then (if kingMoved then (g.whiteCanShortCastle := 0;
							g.whiteCanLongCastle := 0)
				     else if rookMoved & fromC = A1
					 then g.whiteCanLongCastle := 0
				     else if rookMoved & fromC = H1
					 then g.whiteCanShortCastle := 0);
			    if color = BLACK
			       then (if kingMoved then (g.blackCanShortCastle := 0;
							g.blackCanLongCastle := 0)
				     else if rookMoved & fromC = A8
					 then g.blackCanLongCastle := 0
				     else if rookMoved & fromC = H8
					 then g.blackCanShortCastle := 0))
                     end
                 
               function updateKingLoc() = 
		     if      p = WHITE_KING then g.whiteKingLoc := toC
		     else if p = BLACK_KING then g.blackKingLoc := toC
               
	       
               function updateFiftyMoves() =
	             let var capturedOrPawnPush :=
		                           p.piece = PAWN | captureP <> EMPTY
                     in
		         if capturedOrPawnPush
			     then g.fiftyMoveCounter := 1
			     else g.fiftyMoveCounter := g.fiftyMoveCounter + 1
                     end
		     
	       function updateTurn() =
	             if g.turn = WHITE then g.turn := BLACK
		                       else g.turn := WHITE

		       
               function handlePawnPromo() =
	             if p = WHITE_PAWN & toC.rank=7 then
		         (print("Enter to promote pawn: Q, R, B, N\n");
			  let var buffer := getchar()
			      function skipto() =
		              (buffer := getchar();
                                while buffer=" " | buffer="\n"
                                do buffer := getchar())
			  in
			      skipto();
			      while 1 do
			          let var num := ord(buffer)
				  in				  
			              if num = 81 | num = 113 then (setPiece(b, toC, WHITE_QUEEN); break)
				      else if num = 82 | num = 114 then (setPiece(b, toC, WHITE_ROOK); break)
				      else if num = 66 | num = 98 then (setPiece(b, toC, WHITE_BISHOP); break)
				      else if num = 78 | num = 110 then (setPiece(b, toC, WHITE_KNIGHT); break)
				      else (print("Invalid input, try again:\n"); skipto())
				  end 
                          end)
		     else if p = BLACK_PAWN & toC.rank=0 then
			     (print("Enter to promote pawn: Q, R, B, N\n");
			      let var buffer := getchar()
			          function skipto() =
				    (buffer := getchar();
				      while buffer=" " | buffer="\n"
				      do buffer := getchar())
			      in
			          skipto();
				  while 1 do
			          let var num := ord(buffer)
				  in				  
			              if num = 81 | num = 113 then (setPiece(b, toC, BLACK_QUEEN); break)
				      else if num = 82 | num = 114 then (setPiece(b, toC, BLACK_ROOK); break)
				      else if num = 66 | num = 98 then (setPiece(b, toC, BLACK_BISHOP); break)
				      else if num = 78 | num = 110 then (setPiece(b, toC, BLACK_KNIGHT); break)
				      else (print("Invalid input, try again:\n"); skipto())
				  end
			      end)

				
			  
	   in 
               if legalMove(g, fromC, toC)
	           then (if isEnPassant()
			    then moveEnPassant()
			 else if isCastling()
			    then moveCastling()
			 else
			    (setPiece(b, toC, p);
		             setPiece(b, fromC, EMPTY));

                         if g.turn = WHITE
			     then if blackInCheck(g) then print("Black is now in check\n");
			 if g.turn = BLACK
			     then if whiteInCheck(g) then print("White is now in check\n");
		         
			 updateEnPassantable();
			 updateCanCastle();
			 updateKingLoc();
			 updateTurn();
			 handlePawnPromo();
			 printMove(p, fromC, toC);
			 printBoard(g);
			 updateFiftyMoves();

                         /* We check at 100 since the 50 move rule happens when
			    both players moved 50 times without a pawn move or
			    a capture */ 
			 if g.fiftyMoveCounter = 100 then print("Draw by 50 move rule\n"))

                   else (print("\nInvalid Move: ");
             	         printMove(p, fromC, toC))
            end

            /****************************************
	      Main Game Loop Helper Functions
	     ****************************************/
	     function printTurnMessage (g : game) =
	         if g.turn = WHITE then print("White to move: ")
		                   else print("Black to move: ")


             function validMoveStr (fromFile : string, fromRank : string,
	                            toFile : string, toRank : string) : bool =
                 let function validFileChar (f : string) : bool =
		         let var num : int := ord(f)
			     var upper := (num >= 65) & (num <= 72)
			     var lower := (num >= 97) & (num <= 104)
			 in
			     upper | lower
			 end

                    
		     function validRankChar (r : string) : bool =
		         let var num := ord(r)
			 in
			    (num >= 49) & (num <= 56)
			 end
			 
	          in
                     validFileChar(fromFile) & validRankChar(fromRank) &
		     validFileChar(toFile) & validRankChar(toRank)
		  end


             function strToCoordinate (f : string, r : string) : coordinate =
                 let function fileCharToInt (f : string) : int =
	                 let var num := ord(f)
		         in
		             if (num >= 65) & (num <= 72)
		             then num - 65
			     else num - 97
	                 end 

                     function rankCharToInt (r : string) : int = ord(r) - 49

		     var file := fileCharToInt(f)
		     var rank := rankCharToInt(r)
		 in
		     coordinate{file=file, rank=rank}
		 end 


             function readMove () : moveCoords =
	         let var buffer : string := ""
		     
		     function skipto() =
		         (buffer := getchar();
                          while buffer=" " | buffer="\n"
                            do buffer := getchar())

                     var fromFile := (skipto(); buffer)
		     var fromRank := (skipto(); buffer)
		     var toFile := (skipto(); buffer)
		     var toRank := (skipto(); buffer)
		 in
		     if validMoveStr(fromFile, fromRank, toFile, toRank)
		         then moveCoords{fromC=strToCoordinate(fromFile, fromRank),
				         toC=strToCoordinate(toFile, toRank)}
			 else (print("Invalid input. Try again:\n");
			       readMove());
		    
		 end


            /*********************************************************
	              Time to play Chess! 
	    *********************************************************/
	    function playGame () =
	        let var g := initGame()
		in
		    printBoard(g);
		    print("Welcome! To make a move, type two space-separated coordinates.\nFor example: e2 e4\n");
		    
		    while 1 do
		            if not(sufficientMaterial(g)) then (print("Draw by insufficient material\n");
			                                       break)
                            else
			        let 
				    var noMoves := not(hasAMove(g))
				in
				    /* White checkmated case */
				    if noMoves & g.turn = WHITE & whiteInCheck(g)
					then (print("Checkmate! Black is the winner!\n");
					      break)
				    /* Black checkmated case */ 
				    else if noMoves & g.turn = BLACK & blackInCheck(g)
					then (print("Checkmate! White is the winner!\n");
					      break)
				    /* Stalemate */ 				
				    else if noMoves
					then (print("Draw by stalemate!\n");
					      break)
				    else
				      let 
					  var turnMsg := printTurnMessage(g)
					  var moveCoordinates : moveCoords := readMove()
					  var fromC := moveCoordinates.fromC
					  var toC := moveCoordinates.toC  
				      in
					  move(g, fromC, toC)
				      end
				 end
	        end
		   
in
    playGame()
end