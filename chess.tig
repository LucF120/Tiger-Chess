let
    /**********************
          Color Constants  
    ***********************/ 
    var WHITE := 0
    var BLACK := 1

    /***********************
          Piece Constants  
    ************************/ 

    var PAWN := 0
    var ROOK := 1
    var KNIGHT := 2
    var BISHOP := 3
    var QUEEN := 4
    var KING := 5


    /***********************
          Types   
    ************************/
    type bool = int 
    type coordinate = {file: int, rank: int}
    type piece = {color: int, piece: int}

    type row = array of piece    
    type board = array of row

    type game = {board: board,
                 turn: int,
		 whiteKingLoc: coordinate,
                 blackKingLoc: coordinate,
		 whiteCanShortCastle: bool,
		 blackCanShortCastle: bool,
		 whiteCanLongCastle: bool,
		 blackCanLongCastle: bool,
		 enPassantable: coordinate,
		 fiftyMoveCounter: int}

    /****************************
        Piece Constants
    ****************************/

     var EMPTY := piece{color=-1, piece=-1}
     
     var WHITE_PAWN := piece{color=WHITE, piece=PAWN}
     var WHITE_ROOK := piece{color=WHITE, piece=ROOK}
     var WHITE_KNIGHT := piece{color=WHITE, piece=KNIGHT}
     var WHITE_BISHOP := piece{color=WHITE, piece=BISHOP}
     var WHITE_QUEEN := piece{color=WHITE, piece=QUEEN}
     var WHITE_KING := piece{color=WHITE, piece=KING}
     
     var BLACK_PAWN := piece{color=BLACK, piece=PAWN}
     var BLACK_ROOK := piece{color=BLACK, piece=ROOK}
     var BLACK_KNIGHT := piece{color=BLACK, piece=KNIGHT}
     var BLACK_BISHOP := piece{color=BLACK, piece=BISHOP}
     var BLACK_QUEEN := piece{color=BLACK, piece=QUEEN}
     var BLACK_KING := piece{color=BLACK, piece=KING}

     
    /****************************
           Coordinate Constants
     ***************************/
     var NO_COORD := coordinate{file=-1, rank=-1}
     var A1 := coordinate{file=0, rank=0}
     var A2 := coordinate{file=0, rank=1}
     var A3 := coordinate{file=0, rank=2}
     var A4 := coordinate{file=0, rank=3}
     var A5 := coordinate{file=0, rank=4}
     var A6 := coordinate{file=0, rank=5}
     var A7 := coordinate{file=0, rank=6}
     var A8 := coordinate{file=0, rank=7}

     var B1 := coordinate{file=1, rank=0}
     var B2 := coordinate{file=1, rank=1}
     var B3 := coordinate{file=1, rank=2}
     var B4 := coordinate{file=1, rank=3}
     var B5 := coordinate{file=1, rank=4}
     var B6 := coordinate{file=1, rank=5}
     var B7 := coordinate{file=1, rank=6}
     var B8 := coordinate{file=1, rank=7}
     
     var C1 := coordinate{file=2, rank=0}
     var C2 := coordinate{file=2, rank=1}
     var C3 := coordinate{file=2, rank=2}
     var C4 := coordinate{file=2, rank=3}
     var C5 := coordinate{file=2, rank=4}
     var C6 := coordinate{file=2, rank=5}
     var C7 := coordinate{file=2, rank=6}
     var C8 := coordinate{file=2, rank=7}
         
     var D1 := coordinate{file=3, rank=0}
     var D2 := coordinate{file=3, rank=1}
     var D3 := coordinate{file=3, rank=2}
     var D4 := coordinate{file=3, rank=3}
     var D5 := coordinate{file=3, rank=4}
     var D6 := coordinate{file=3, rank=5}
     var D7 := coordinate{file=3, rank=6}
     var D8 := coordinate{file=3, rank=7}
     
     var E1 := coordinate{file=4, rank=0}
     var E2 := coordinate{file=4, rank=1}
     var E3 := coordinate{file=4, rank=2}
     var E4 := coordinate{file=4, rank=3}
     var E5 := coordinate{file=4, rank=4}
     var E6 := coordinate{file=4, rank=5}
     var E7 := coordinate{file=4, rank=6}
     var E8 := coordinate{file=4, rank=7}
     
     var F1 := coordinate{file=5, rank=0}
     var F2 := coordinate{file=5, rank=1}
     var F3 := coordinate{file=5, rank=2}
     var F4 := coordinate{file=5, rank=3}
     var F5 := coordinate{file=5, rank=4}
     var F6 := coordinate{file=5, rank=5}
     var F7 := coordinate{file=5, rank=6}
     var F8 := coordinate{file=5, rank=7}
     
     var G1 := coordinate{file=6, rank=0}
     var G2 := coordinate{file=6, rank=1}
     var G3 := coordinate{file=6, rank=2}
     var G4 := coordinate{file=6, rank=3}
     var G5 := coordinate{file=6, rank=4}
     var G6 := coordinate{file=6, rank=5}
     var G7 := coordinate{file=6, rank=6}
     var G8 := coordinate{file=6, rank=7}
     
     var H1 := coordinate{file=7, rank=0}
     var H2 := coordinate{file=7, rank=1}
     var H3 := coordinate{file=7, rank=2}
     var H4 := coordinate{file=7, rank=3}
     var H5 := coordinate{file=7, rank=4}
     var H6 := coordinate{file=7, rank=5}
     var H7 := coordinate{file=7, rank=6}
     var H8 := coordinate{file=7, rank=7}

     /*****************************************/
     
     /* Absolute value function */
     function abs(x : int) : int =
         if x < 0 then x * -1 else x
	 
     /* Checks if file and rank are equal to a coordiante */ 
     function isSquare (file : int, rank : int, square : coordinate) : bool =
         if (file = square.file & rank = square.rank)
	     then 1
	     else 0

     /* Initially,
        - the pieces are on their starting squares,
        - it is white's turn. The kings are on e1 and e8,
	- no pawn moved 2 squares last turn (thus nothing can be captured via
            en passant)
	- the fifty move counter starts at 0
     */
     function initGame() : game =
     let 
         /* Initializes the board at the beginning of the game
	    - White pawns on the 2nd rank, black pawns on the 7th rank
	    - Rank 1 contains white: rook, knight, bishop, queen, king, bishop, knight, rook
	    - Rank 8 contains black: rook, knight, bishop, queen, king, bishop, knight, rook
	    - White and black can still castle short or long 
	 */ 
	 function initBoard () : board =
		 /* Need to make the rows here so they dont point to same object */
	     let var r0 := row [8] of EMPTY
		 var r1 := row [8] of WHITE_PAWN
		 var r2 := row [8] of EMPTY
		 var r3 := row [8] of EMPTY
		 var r4 := row [8] of EMPTY
		 var r5 := row [8] of EMPTY
		 var r6 := row [8] of BLACK_PAWN
		 var r7 := row [8] of EMPTY

		 var b := board [8] of r0
	     in
		 /* Make each row a unique array */ 
		 b[1] := r1;
		 b[2] := r2;
		 b[3] := r3;
		 b[4] := r4;
		 b[5] := r5;
		 b[6] := r6;
		 b[7] := r7;

		 /* Insert major pieces at correct location
		    Note: Pawns already were initialized.
		  */ 
		 for rank := 0 to 7 do
		     for file := 0 to 7 do	
			 if (rank = 0) then 
			       (if     (file = 0 | file=7) then b[rank][file] := WHITE_ROOK
			       else if (file = 1 | file=6) then b[rank][file] := WHITE_KNIGHT
			       else if (file = 2 | file=5) then b[rank][file] := WHITE_BISHOP
			       else if (file = 3)          then b[rank][file] := WHITE_QUEEN
			       else if (file = 4)          then b[rank][file] := WHITE_KING)
			 else if (rank = 7) then
			       (if     (file = 0 | file=7) then b[rank][file] := BLACK_ROOK
			       else if (file = 1 | file=6) then b[rank][file] := BLACK_KNIGHT
			       else if (file = 2 | file=5) then b[rank][file] := BLACK_BISHOP
			       else if (file = 3)          then b[rank][file] := BLACK_QUEEN
			       else if (file = 4)          then b[rank][file] := BLACK_KING);

		 b 	/* Returns the updated board */ 
	     end
           in
	       game{board=initBoard(),
	            turn=WHITE,
		    whiteKingLoc=E1,
		    blackKingLoc=E8,
		    whiteCanShortCastle=1,
		    blackCanShortCastle=1,
		    whiteCanLongCastle=1,
		    blackCanLongCastle=1,
		    enPassantable=NO_COORD,
		    fiftyMoveCounter=0}
	   end 


       function printMove(fromC : coordinate, toC : coordinate) =
           let function printCoordinate(c : coordinate) =
               let function fileToStr(f : int) : string = chr(f + 97)
	           function rankToStr(r : int) : string = chr(r + 49)
	           var str := concat(fileToStr(c.file), rankToStr(c.rank))
	       in
	           print(str)
               end
	   in
	       print("Moved ");
	       printCoordinate(fromC);
	       print(" to ");
	       printCoordinate(toC);
	       print("\n")
	   end
	       
	
       function printBoard (g : game) =
           let var b := g.board  
	       var rank := 7
	   
	       /* Emulators for MIPS R2000 don't seem to support unicode sadly */ 
               function printPiece (p : piece) =
                   if      p = WHITE_PAWN   then print("WP")
	           else if p = WHITE_ROOK   then print("WR")
	           else if p = WHITE_KNIGHT then print("WN")
	           else if p = WHITE_BISHOP then print("WB")
	           else if p = WHITE_QUEEN  then print("WQ")
	           else if p = WHITE_KING   then print("WK")
	           else if p = BLACK_PAWN   then print("BP")
	           else if p = BLACK_ROOK   then print("BR")
	           else if p = BLACK_KNIGHT then print("BN")
	           else if p = BLACK_BISHOP then print("BB")
	           else if p = BLACK_QUEEN  then print("BQ")
	           else if p = BLACK_KING   then print("BK")
	           else print ("  ")

	   in 
             while rank >= 0 do	     
	       (print("     -----------------------------------------\n");
	        print("   "); print(chr(rank + 49)); print(" | ");
	        for file := 0 to 7 do
	           let var p := b[rank][file]
		   in
		       printPiece(p);
		       print(" | ")
		   end;	
	       print("\n");
	       rank := rank - 1);
	     print("     -----------------------------------------\n");
	     print("       a    b    c    d    e    f    g    h\n\n")
	   end


       /***********************************
            Piece predicate functions
	***********************************/
       function isKnight(p : piece) : bool =
           p.piece = KNIGHT
       function isRook(p : piece) : bool =
           p.piece = ROOK
       function isBishop(p : piece) : bool =
           p.piece = BISHOP
       function isPawn(p : piece) : bool =
           p.piece = PAWN
       function isQueen(p : piece) : bool =
           p.piece = QUEEN
       function isKing(p : piece) : bool =
           p.piece = KING

       function isWhite(p : piece) : bool =
           p.color = WHITE
       function isBlack(p : piece) : bool =
           p.color = BLACK

       /****************************************
             Helpers for Legal Move Checks
	****************************************/
	
       /* Check if two coordinates are on the same diagonal. */
       function isDiagonal(fromC : coordinate, toC : coordinate) : bool =
           let var dx := abs(fromC.file - toC.file) 
	       var dy := abs(fromC.rank - toC.rank)
	   in
	       (dx = dy) & (dx <> 0)
	   end	   
	   

       function canSeeSquare(b : board, fromC : coordinate, toC : coordinate) : bool =
           let function noPiecesBetweenHorizontally (b : board, fromC : coordinate, toC : coordinate) : bool =
               	    let var low := if fromC.file <= toC.file then fromC.file else toC.file
	       		var high := if fromC.file <= toC.file then toC.file else fromC.file	       
	       		var rank := fromC.rank /* Invariant: fromC.rank = toC.rank */ 
	       		var res := 1
	    	     in
               	        for file := (low + 1) to (high - 1) do
	           	    if getPiece(b, coordinate{file=file, rank=rank}) <> EMPTY
		       	       then (res := 0; break);
	       		res			
               	     end
		     
	       function noPiecesBetweenVertically (b : board, fromC : coordinate, toC : coordinate) : bool =
                     let var low := if fromC.rank <= toC.rank then fromC.rank else toC.rank
	                 var high := if fromC.rank <= toC.rank then toC.rank else fromC.rank	       
	                 var file := fromC.file /* Invariant: fromC.file = toC.file */ 
	                 var res := 1
	             in
                         for rank := (low + 1) to (high - 1) do
	                     if getPiece(b, coordinate{file=file, rank=rank}) <> EMPTY
		                 then (res := 0; break);
	                 res
	             end

       
               function noPiecesBetweenDiagonally (b : board, fromC : coordinate, toC : coordinate) : bool =
               	     let var lowRank := (if fromC.rank <= toC.rank then fromC.rank else toC.rank) + 1
	                 var highRank := (if fromC.rank <= toC.rank then toC.rank else fromC.rank)
	                 var lowFile := (if fromC.file <= toC.file then fromC.file else toC.file) + 1
	                 var highFile := (if fromC.file <= toC.file then toC.file else fromC.file)

	                 var res := 1
	             in
                         while lowRank <> highRank do
	                     (if getPiece(b, coordinate{file=lowFile, rank=lowRank}) <> EMPTY
		                 then (res :=0; break);
		              lowRank := lowRank + 1;
		              lowFile := lowFile + 1);
		    
	                 res 
	             end
	   in 
               if fromC = toC then 0   /* Pieces can't move to themselves */
	       else
	           let var horizontal := fromC.rank = toC.rank
	               var vertical   := fromC.file = toC.file
		       var diagonal   := isDiagonal(fromC, toC)
	           in
	               if       horizontal then noPiecesBetweenHorizontally(b, fromC, toC)
		       else if  vertical   then noPiecesBetweenVertically(b, fromC, toC)
		       else if  diagonal   then noPiecesBetweenDiagonally(b, fromC, toC)
		       else 0
	           end
           end 


       /****************************************
                   Legal Move Checks
	****************************************/
       function legalPawnMove(g : game, p : piece, fromC : coordinate, toC : coordinate) : bool =
           let var b := g.board 
	       var vertical := toC.rank - fromC.rank
	       var horizontal := toC.file - fromC.file

	       var goingUp := vertical > 0
	       var goingDown := vertical < 0	       
	       var wrongDirection := (goingDown & isWhite(p)) | (goingUp & isBlack(p))
	       var capturing := abs(vertical) = 1 & abs(horizontal) = 1	       
	       
	       function nextToEnPassantable () : bool =
	           let var leftLegal := 0
		       var rightLegal := 0
		       var leftFile := fromC.file - 1
		       var rightFile := fromC.file + 1
		       var currPiece := getPiece(b, fromC)
		       var currColor := currPiece.color
		       var leftPiece := getPiece(b, coordinate{file=leftFile,
							       rank=fromC.rank})
                       var rightPiece := getPiece(b, coordinate{file=rightFile,
							        rank=fromC.rank})
							       
		   in 
	               if leftPiece <> EMPTY & leftFile >= 0
		           then leftLegal :=
			       (g.enPassantable.file = leftFile 
			        & leftPiece.color <> currColor);
				
		       if rightPiece <> EMPTY & rightFile <= 7
		           then rightLegal :=
			       (g.enPassantable.file = rightFile 
			        & rightPiece.color <> currColor);

                       /* True if an en passantable pawn is on the left or right */ 
                       leftLegal | rightLegal
		   end
		   
	       var canEnPassant := nextToEnPassantable()
		
		       

	   in
	       /* FAIL: White pawn going down or black pawn going up */ 
	       if wrongDirection
	           then 0

               /* Double jump case only legal on first move */ 
	       else if (abs(vertical) = 2 & horizontal = 0)
	           then (isWhite(p) & fromC.rank = 1) | (isBlack(p) & fromC.rank = 6)

               /* Capture case. Only legal if there is a piece to capture
	        */
	       else if capturing & canEnPassant = 0
	           then (getPiece(b, toC) <> EMPTY)

               /* En passant case. Only legal if the square adjacent has an
	          en passantable pawn */ 
               else if (capturing & canEnPassant)
	           then 1 

               /* One move forward case. Only legal if there is not a piece
	          on that square
		*/ 
               else if (abs(vertical) = 1 & abs(horizontal) = 0)
	           then (getPiece(b, toC) = EMPTY)

               else 0
	   end 
	       
	            
       function legalKnightMove(fromC : coordinate, toC : coordinate) : bool =
           let var vertical   := abs(fromC.rank - toC.rank)
	       var horizontal := abs(fromC.file - toC.file)
	   in
	       (horizontal = 2 & vertical = 1) | (horizontal = 1 & vertical = 2)
	   end
	   
       function legalRookMove (fromC : coordinate, toC : coordinate) : bool =
           fromC.rank = toC.rank | fromC.file = toC.file

       function legalBishopMove (fromC : coordinate, toC : coordinate) : bool =
           isDiagonal(fromC, toC)

       function legalQueenMove (fromC : coordinate, toC : coordinate) : bool =
           legalRookMove(fromC, toC) | legalBishopMove(fromC, toC)

       /* TODO: IMPLEMENT THIS */ 
       function legalKingMove (b : board, p : piece, fromC : coordinate, toC : coordinate) : bool =
           0
       

       function attackingWhiteKing(g : game, c : coordinate) : bool =
           let var p := getPiece(g.board, c)
	   in
	       /* This will return false for empty squares and squares with
	          white pieces */ 
	       if p.color = BLACK 
	           then canSeeSquare(g.board, c, g.whiteKingLoc)
	       else 0
	   end 

       
       function attackingBlackKing(g : game, c : coordinate) : bool =
           let var p := getPiece(g.board, c)
	   in
	       /* This will return false for empty squares and squares with
	          black pieces */ 
	       if p.color = WHITE
	           then canSeeSquare(g.board, c, g.blackKingLoc)
	       else 0
	   end

       /* Iterates through all squares, and checks if they are attacking the
          white king
          - This is slightly inefficient. A better way would be to get all
	    the squares that can see the whiteKingLoc, and then only iterate
	    through those coordinates. 
        */
       function whiteInCheck(g : game) : bool =
           let var res : bool := 0
	   in 
               for rank := 0 to 7 do
	           for file := 0 to 7 do
	               if attackingWhiteKing(g, coordinate{file=file, rank=rank})
		           then (res := 1; break);

               res
           end

       function blackInCheck(g : game) : bool =
           let var res : bool := 0
	   in 
               for rank := 0 to 7 do
	           for file := 0 to 7 do
	               if attackingBlackKing(g, coordinate{file=file, rank=rank})
		           then (res := 1; break);

               res
           end 	       
			   
	           
       function movingExposesMyKing(g : game, c : coordinate, color : int) : bool =
           let var canSeeMyKing := if color = WHITE
	                              then canSeeSquare(g.board, c, g.whiteKingLoc)
	                              else canSeeSquare(g.board, c, g.blackKingLoc)
               var exposes := 0
	       var p := getPiece(g.board, c)
           in
	       if canSeeMyKing & color = WHITE
	          then (setPiece(g.board, c, EMPTY); /* Temp remove the piece */
		        exposes := whiteInCheck(g);
			setPiece(g.board, c, p) /* Insert the piece back */)
			
	       else if canSeeMyKing & color = BLACK
	                then (setPiece(g.board, c, EMPTY);
		              exposes := blackInCheck(g);
			      setPiece(g.board, c, p));

               exposes
           end 			      
				    

	   
       function legalMove(g : game, fromC : coordinate, toC : coordinate) : bool =
           let var b := g.board
	       var pFrom := getPiece(b, fromC)
	       var pTo   := getPiece(b, toC)
	   in
	       /* FAIL: From square is empty */ 
	       if      (pFrom = EMPTY) then 0

               /* FAIL: Trying to capture your own piece */ 
               else if (pFrom.color = pTo.color) then 0

               /* FAIL: From piece is not a knight, and can't see dest. square */
	       else if (isKnight(pFrom) = 0 &
	                canSeeSquare(b, fromC, toC) = 0)  then 0
 
               /* FAIL: Moving gets YOUR king killed */
               else if movingExposesMyKing(g, fromC, pFrom.color) then 0

	       else if isRook(pFrom)    then legalRookMove(fromC, toC)
	       else if isKnight(pFrom)  then legalKnightMove(fromC, toC)
	       else if isBishop(pFrom)  then legalBishopMove(fromC, toC)
	       else if isQueen(pFrom)   then legalQueenMove(fromC, toC)
	       else if isPawn(pFrom)    then legalPawnMove(g, pFrom, fromC, toC)
	       /* TODO: IMPLEMENT THIS 
	       else if isKing(pFrom)    then legalKingMove(b, pFrom, fromC, toC)
	       */

	       else 0
	   end

       /****************************************
                       Moving Pieces
        ****************************************/
       /* Index into board to get a piece at a coord */ 
       function getPiece(b : board, c : coordinate) : piece =
           b[c.rank][c.file]


       /* Index into board to set a piece at a coord */
       function setPiece(b : board, c : coordinate, p : piece) =
           b[c.rank][c.file] := p
	   
       function move(g : game, fromC : coordinate, toC : coordinate) =
           let var b := g.board
               var p := getPiece(b, fromC)
	       /* If a pawn moved 2 squares, set that coordinate to be
	          en passantable for next turn */ 
	       function updateEnPassantable() =
		   let function pawnDoubleJump() : bool =
			   let var vertical := abs(fromC.rank - toC.rank)
			   in
			       if isPawn(p) & vertical = 2
				   then 1
				   else 0
			   end
	           in
		       if pawnDoubleJump()
		           then g.enPassantable := toC
		           else g.enPassantable := NO_COORD 
		   end

               /* Return true if a move is an en passant */ 
               function isEnPassant() : bool =
	           let var vertical := abs(fromC.rank - toC.rank)
		       var horizontal := abs(fromC.file - toC.file)
		   in
		       /* It's an en passant if it's a pawn capture where
		          the destination square is empty */ 
		       if (isPawn(p) & vertical = 1 & horizontal = 1 &
		          getPiece(b, toC) = EMPTY)
			  then 1
			  else 0
	           end
			  
	       /* Special handling for the en passant move, since
	          it's the only move where a piece gets captured on a square
		  different than the destination square */ 
	       function moveEnPassant() =
	           let var captureC := if p.color = WHITE
		                         then coordinate{file=toC.file,
          				                 rank=toC.rank - 1}
					 else coordinate{file=toC.file,
					                 rank=toC.rank + 1}
                   in
		       setPiece(b, fromC, EMPTY);
		       setPiece(b, toC, p);
		       setPiece(b, captureC, EMPTY)
                   end

                function isCastling() : bool =
		    let var horizontal := fromC.file - toC.file
		        var isKing := p.piece = KING
	            in
		        isKing & abs(horizontal) = 2
		    end 			
			
                function moveCastling() =
		    let var horizontal := fromC.file - toC.file 
		    in
		        /* White king long castling case */ 
			if p = WHITE_KING & horizontal = -2
			   then (setPiece(b, C1, WHITE_KING);
			         setPiece(b, D1, WHITE_ROOK);
				 setPiece(b, A1, EMPTY);
				 setPiece(b, E1, EMPTY))

                        /* White king short castling */ 
			else if p = WHITE_KING & horizontal = 2
			   then (setPiece(b, G1, WHITE_KING);
			         setPiece(b, F1, WHITE_ROOK);
				 setPiece(b, H1, EMPTY);
				 setPiece(b, E1, EMPTY))

                        /* Black king long castling case */ 
			else if p = BLACK_KING & horizontal = -2
			   then (setPiece(b, C8, BLACK_KING);
			         setPiece(b, D8, BLACK_ROOK);
				 setPiece(b, A8, EMPTY);
				 setPiece(b, E8, EMPTY))

                        /* Black king short castling */ 
			else if p = BLACK_KING & horizontal = 2
			   then (setPiece(b, G8, BLACK_KING);
			         setPiece(b, F8, BLACK_ROOK);
				 setPiece(b, H8, EMPTY);
				 setPiece(b, E8, EMPTY))
                     end 			  
		    
                /* The king can never castle short or long IF:
		     - The king moved (either normally or by castling)
		   The king can never castle short IF:
		     - The h file rook moved 
		   The king can never castle long IF:
		     - The a file rook moved 
		 */
                function updateCanCastle() =
		    let var color := p.color
		        var kingMoved := p.piece = KING
			var rookMoved := p.piece = ROOK
			var canStillCastle := g.whiteCanShortCastle | g.whiteCanLongCastle
			                    | g.blackCanShortCastle | g.blackCanLongCastle 
	            in
		        /* Only need to check this if any of the canStillCastle
			   bools are true */ 
		        if canStillCastle then 
			    (if color = WHITE
			       then (if kingMoved then (g.whiteCanShortCastle := 0;
							g.whiteCanLongCastle := 0)
				     else if rookMoved & fromC = A1
					 then g.whiteCanLongCastle := 0
				     else if rookMoved & fromC = H1
					 then g.whiteCanShortCastle := 0);
			    if color = BLACK
			       then (if kingMoved then (g.blackCanShortCastle := 0;
							g.blackCanLongCastle := 0)
				     else if rookMoved & fromC = A8
					 then g.blackCanLongCastle := 0
				     else if rookMoved & fromC = H8
					 then g.blackCanShortCastle := 0))
                     end
                 
                 function updateKingLoc() = 
		     if      p = WHITE_KING then g.whiteKingLoc := toC
		     else if p = BLACK_KING then g.blackKingLoc := toC 
	   in 
               if legalMove(g, fromC, toC)
	           then (if isEnPassant()
			    then moveEnPassant()
			 else if isCastling()
			    then moveCastling()
			 else
			    (setPiece(b, toC, p);
		             setPiece(b, fromC, EMPTY));
		         
			 updateEnPassantable();
			 updateCanCastle();
			 updateKingLoc(); 
			 printMove(fromC, toC);
			 printBoard(g))			

                   else (print("\nInvalid Move: You ");
             	         printMove(fromC, toC))
            end 
		        
		   
in
     let var g := initGame()
     in     
         printBoard(g);
	 move(g, E2, E4);
	 move(g, E7, E5);
	 move(g, B1, C3);
	 
	 /* Illegal moves
	 ******************/
	 move(g, F1, H3);
	 move(g, E4, E5);
	 move(g, D1, D3);
	 move(g, D1, G1);
	 /****************/

         /* Trying en passant
	 ********************/
	 move(g, H2, H4);
	 move(g, H4, H5);
	 move(g, G7, G5);
	 move(g, H5, G6);

         /* Reset
	 ***************/
	 g := initGame();

         /*  Try illegal en passants 
	 **************************/
	 move(g, E2, E4);
	 move(g, E4, F5);
	 move(g, F7, F5);
	 move(g, F5, F4);
	 move(g, E4, F5);

         /* Legal en passant */
	 move(g, G2, G4);
	 move(g, F4, G3)
     end 
end
  	
